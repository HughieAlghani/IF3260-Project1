<canvas id="canvas" style="width: 100%;"></canvas>
<input type="text" id="R" name="R" value="0">
<input type="text" id="G" name="G" value="0">
<input type="text" id="B" name="B" value="0">

<form>
<input type="radio" id="pick" name="tool" value="P">
<label for="pick">Pick Tool</label>
<input type="radio" id="rectangle" name="tool" value="R">
<label for="rectangle">Rectangle</label>
</form>

<!-- vertex shader -->
<script  id="vertex-shader-2d" type="x-shader/x-vertex">
attribute vec2 a_position;

uniform vec2 u_resolution;

void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position / u_resolution;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0;

   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
}
</script>
<!-- fragment shader -->
<script  id="fragment-shader-2d" type="x-shader/x-fragment">
precision mediump float;

uniform vec4 u_color;

void main() {
   gl_FragColor = u_color;
}
</script>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>

<script>
"use strict";

function pointer(event) {
    return { x : event.clientX, y : event.clientY };
}

function main() {
  var canvas = document.querySelector("#canvas");
  var gl = canvas.getContext("webgl");
  if (!gl) {
    return;
  }

  // setup GLSL program
  var program = webglUtils.createProgramFromScripts(gl, ["vertex-shader-2d", "fragment-shader-2d"]);

  // look up where the vertex data needs to go.
  var positionLocation = gl.getAttribLocation(program, "a_position");

  // lookup uniforms
  var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
  var colorLocation = gl.getUniformLocation(program, "u_color");

  // Create a buffer to put positions in
  var positionBuffer = gl.createBuffer();

  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  var pos0;
  var pos1;
  var color = [document.getElementById("R").value / 255, document.getElementById("G").value / 255, document.getElementById("B").value / 255, 1];
  var click = false;

    document.getElementById("canvas").addEventListener("mousedown", function(e) {
        if (document.getElementById("rectangle").checked == true) {
            pos0 = pointer(e);
            click = true;
        }
    });

    document.getElementById("canvas").addEventListener("mousemove", function(e) {
        if (document.getElementById("rectangle").checked == true) {
            if (click) {
                pos1 = pointer(e);

                if (e.ctrlKey) {
                    var h = Math.abs(pos0.y - pos1.y);
                    var w = Math.abs(pos0.x - pos1.x);

                    var max_param = Math.max(h,w);

                    if (pos1.x >= pos0.x && pos1.y >= pos0.y) {
                        pos1.x = pos0.x + max_param;
                        pos1.y = pos0.y + max_param;
                    } else if (pos1.x >= pos0.x && pos1.y < pos0.y) {
                        pos1.x = pos0.x + max_param;
                        pos1.y = pos0.y - max_param;
                    } else if (pos1.x < pos0.x && pos1.y < pos0.y) {
                        pos1.x = pos0.x - max_param;
                        pos1.y = pos0.y - max_param;
                    } else {
                        pos1.x = pos0.x - max_param;
                        pos1.y = pos0.y + max_param;
                    }
                    drawScene();
                } else {
                    drawScene();
                }
            }
        }
    });

    document.getElementById("canvas").addEventListener("mouseup", function(e) {
        if (document.getElementById("rectangle").checked == true) {
            click = false;
        }
    });

function updateColor() {
    color = [document.getElementById("R").value / 255, document.getElementById("G").value / 255, document.getElementById("B").value / 255, 1];
}

function drawScene() {
    webglUtils.resizeCanvasToDisplaySize(gl.canvas);

    // Tell WebGL how to convert from clip space to pixels
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // Clear the canvas.
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Tell it to use our program (pair of shaders)
    gl.useProgram(program);

    // Turn on the attribute
    gl.enableVertexAttribArray(positionLocation);

    // Bind the position buffer.
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    // Setup a rectangle
    setRectangle(gl, pos0.x, pos0.y, pos1.x, pos1.y);

    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    var size = 2;          // 2 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        positionLocation, size, type, normalize, stride, offset);

    // set the resolution
    updateColor();
    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

    // set the color
    gl.uniform4fv(colorLocation, color);

    // Draw the rectangle.
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
}

}

// Fill the buffer with the values that define a rectangle.
function setRectangle(gl, x1, y1, x2, y2) {
//   var x1 = x;
//   var x2 = x + width;
//   var y1 = y;
//   var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2,
  ]), gl.STATIC_DRAW);
}

main();

</script>